#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <set>
#include <map>

using namespace std;

// Structure to represent a word w = O^a X^b
struct WordParams {
    int a, b;
};

// Calculate the number of distinct substrings of w_u + w_v
// where w_u = O^a X^b and w_v = O^c X^d
long long calculate_power(const WordParams& u, const WordParams& v) {
    long long a = u.a;
    long long b = u.b;
    long long c = v.a;
    long long d = v.b;

    // The number of distinct substrings of S = O^a X^b O^c X^d can be derived by counting
    // substrings of different forms. The forms are mutually exclusive based on transition counts.
    // Forms:
    // 1. O^k (from O^a or O^c): max(a, c) distinct strings
    // 2. X^k (from X^b or X^d): max(b, d) distinct strings
    // 3. O^i X^j (from O^a X^b or O^c X^d): Union of rectangles [1, a]x[1, b] and [1, c]x[1, d].
    //    Count = ab + cd - min(a, c)*min(b, d).
    // 4. X^j O^k (boundary crossing): b * c distinct strings
    // 5. O^i X^b O^k (boundary crossing): a * c distinct strings
    // 6. X^j O^c X^l (boundary crossing): b * d distinct strings
    // 7. O^i X^b O^c X^l (full crossing): a * d distinct strings
    
    // Summing terms 4-7: bc + ac + bd + ad = (a + b)(c + d).
    
    long long term1 = std::max(a, c);
    long long term2 = std::max(b, d);
    long long term3 = a * b + c * d - std::min(a, c) * std::min(b, d);
    long long term4 = (a + b) * (c + d);

    return term1 + term2 + term3 + term4;
}

int main() {
    // Interactive problem, optimization of I/O
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    if (!(cin >> n)) return 0;

    vector<WordParams> words;
    words.reserve(n);
    
    // Set to store all power values generated by the current set of words
    // Used to detect collisions during generation to ensure unique identification
    set<long long> used_powers;
    
    // Generator state
    // We iterate through possible pairs (a, b) in increasing order of sum = a + b
    // to keep lengths small and maximize the score.
    int current_sum = 2;
    int current_a = 1;
    
    for (int k = 0; k < n; ++k) {
        while (true) {
            // Determine candidate (a, b)
            int a = current_a;
            int b = current_sum - current_a;
            
            WordParams cand = {a, b};
            
            // Check if adding 'cand' causes any collision
            bool ok = true;
            vector<long long> new_vals;
            // We expect roughly 2*k + 1 new values
            new_vals.reserve(2 * k + 1);
            
            // 1. Check self-concatenation P(cand, cand)
            long long p_self = calculate_power(cand, cand);
            if (used_powers.count(p_self)) {
                ok = false;
            } else {
                new_vals.push_back(p_self);
            }
            
            if (ok) {
                // 2. Check cross-concatenations with existing words
                for (int i = 0; i < k; ++i) {
                    long long p1 = calculate_power(cand, words[i]);
                    // Check against global used set
                    if (used_powers.count(p1)) { ok = false; break; }
                    // Check against values generated in this step (internal collision)
                    for (long long v : new_vals) if (v == p1) { ok = false; break; }
                    if (!ok) break;
                    new_vals.push_back(p1);
                    
                    long long p2 = calculate_power(words[i], cand);
                    if (used_powers.count(p2)) { ok = false; break; }
                    for (long long v : new_vals) if (v == p2) { ok = false; break; }
                    if (!ok) break;
                    new_vals.push_back(p2);
                }
            }
            
            // Advance generator for next iteration (whether success or fail)
            current_a++;
            if (current_a >= current_sum) {
                current_sum++;
                current_a = 1;
            }
            
            if (ok) {
                // Found a valid word
                words.push_back(cand);
                for (long long v : new_vals) used_powers.insert(v);
                break; // Proceed to next word k+1
            }
        }
    }
    
    // Output the generated words
    for (int i = 0; i < n; ++i) {
        // Construct string O^a X^b
        for (int j = 0; j < words[i].a; ++j) cout << 'O';
        for (int j = 0; j < words[i].b; ++j) cout << 'X';
        cout << "\n";
    }
    cout << flush;
    
    // Prepare lookup table for queries
    // We need to map power -> (u, v)
    struct Entry {
        long long p;
        int u, v;
        bool operator<(const Entry& other) const {
            return p < other.p;
        }
    };
    
    vector<Entry> lookup;
    lookup.reserve((size_t)n * n);
    
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            long long p = calculate_power(words[i], words[j]);
            lookup.push_back({p, i + 1, j + 1});
        }
    }
    
    // Sort for binary search
    sort(lookup.begin(), lookup.end());
    
    // Read number of queries
    int q;
    if (cin >> q) {
        for (int k = 0; k < q; ++k) {
            long long p_query;
            cin >> p_query;
            
            // Find the pair (u, v) corresponding to p_query
            auto it = lower_bound(lookup.begin(), lookup.end(), Entry{p_query, 0, 0});
            if (it != lookup.end() && it->p == p_query) {
                cout << it->u << " " << it->v << "\n";
            } else {
                // Should not happen based on problem statement
                cout << "1 1\n"; 
            }
            cout << flush;
        }
    }
    
    return 0;
}